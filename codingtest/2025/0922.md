# 입문자를 위한 코테 핵심
## 10회 이진트리 레벨탐색(너비우선탐색 : BFS)

### 최소 점프

from collections import deque

def solution(home):
    answer = 0
    Q = deque()
    Q.append(0)
    L = 1
    while Q:
        n = len(Q)   # n=1 -> 3
        print(L, end=" : ")
        for i in range(n):  # 1번 실행 -> 3
            v = Q.popleft()  # 안에 텅 빈다
            print(v, end=" ")
            for nv in [v-1, v+1, v+5]: # 3개 -> 9개
                if nv > home:
                    continue
                Q.append(nv) # 3개가 추가 -> 9개 추가
        print()
        L += 1

    return L
            
print(solution(10))
print(solution(14))
print(solution(25))
print(solution(24))
print(solution(345))

### 정답
from collections import deque
def BFS(home):
    ch = [0] * 10001
    Q = deque()
    Q.append(0)
    ch[0] = 1
    L = 0
    while Q:
        n = len(Q)
        for i in range(n):
            x = Q.popleft()
            if x == home:
                return L
            for nx in [x-1, x+1, x+5]:
                if nx >= 0 and nx <= 10000 and ch[nx] == 0:
                    Q.append(nx)
                    ch[nx] = 1
        L += 1

def solution(home):
    answer = BFS(home)
    return answer

### 검정색 영역 구하기
from collections import deque
dx = [-1, 0 , 1, 0]
dy = [0, 1, 0, -1]

def BFS(x, y, board):
    ch = [0] * 26
    Q = deque()
    Q.append(0)
    ch[0] = 1
    L = 0
    while Q:
        n = len(Q)
        for k in range(4):
            x = Q.popleft()
            if x == 5 and y == 5:
                return L
            for nx,ny in [x+dx[k], y+dy[k]]:
                if nx >= 0 and nx <= 6 and ny >= 0 and ny <= 6:
                    Q.append([nx,ny])
                    ch[nx] = 1
        L += 1

def solution(board):
    answer = 0
    for i in range(5):
        for j in range(5):
            if board[i][j] == 1:
                answer += 1
                BFS(i, j, board)
    
    return answer

### 정답

from collections import deque
dx = [-1, 0 , 1, 0]
dy = [0, 1, 0, -1]

def BFS(x, y, board):
    Q = deque()
    Q.append([x, y])
    board[x][y] = 0  # 확인한건 0으로 바꿔
    L = 0
    while Q:
        n = len(Q)
        for i in range(n):
            x, y = Q.popleft()  # 꺼내서 x,y 에 넣음
            for k in range(4):
                nx = x + dx[k]
                ny = y + dy[k]
                if nx >= 0 and nx < 5 and ny >= 0 and ny < 5 and board[nx][ny] == 1:
                    Q.append([nx, ny])
                    board[nx][ny] = 0
        L += 1
    

def solution(board):
    answer = 0
    for i in range(5):  # 돌면서 보드를 보다가 1이 발견되면 BFS를 호출한다.
        for j in range(5):
            if board[i][j] == 1:  # 1 발견
                answer += 1    # 영역 하나 발견
                BFS(i, j, board)
    
    return answer

print(solution([[0, 1, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 1, 1, 0]]))
print(solution([[1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [0, 0, 1, 0, 0], [1, 1, 0, 1, 0], [1, 0, 1, 0, 0]]))
print(solution([[0, 0, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [1, 0, 0, 1, 0], [0, 0, 1, 1, 0]]))
print(solution([[0, 0, 0, 0, 1], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 0, 1, 0, 0]]))
