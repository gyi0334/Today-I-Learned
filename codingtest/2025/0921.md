# 입문자를 위한 코테 핵심
## 9회 재귀함수와 DFS

### n! 구하기
cnt = 1
def DFS(n):
    global cnt
    if n == 0:
        return
    else:
        cnt = cnt * n
        DFS(n-1)
        print(cnt, end = ' ')
        

print(DFS(5))             
print(DFS(6))

### 정답
def DFS(n):
    if n == 1:
        return 1
    else:
        return n * DFS(n-1)

print(DFS(5))
print(DFS(6))

### 피보나치 수열
n번째 항의 수를 구하라는 거 같은데
def DFS(n):
    if n == 1:
        return
    else:
        print(n, end=' ')
        DFS(n-1)
              
print(DFS(5))

아 모르것노

### 정답
def DFS(n):
    if n == 1 or n == 2:  # n <= 2 로 해도 되는거 같던데
        return 1
    else;
        return DFS(n-2) + DFS(n-1)

print(DFS(5))
print(DFS(6))

### 검정색 영역 구하기
def solution(board):
    answer = 0
    # for i in range(4) 로 상하좌우 찾기?
    # 1을 찾아서 좌표가 연결된 게 있으면 한덩어리로 취급하면 될 거 같은데
    
    return answer
            
print(solution([[0, 1, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 1, 1, 0]]))
#print(solution([[1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [0, 0, 1, 0, 0], [1, 1, 0, 1, 0], [1, 0, 1, 0, 0]]))
#print(solution([[0, 0, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [1, 0, 0, 1, 0], [0, 0, 1, 1, 0]]))
#print(solution([[0, 0, 0, 0, 1], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 0, 1, 0, 0]]))

### 정답
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]
edf DFS(x, y, board):
    board[x][y] = 0
    for k in range(4):
        nx = x + dx[k]
        ny = y + dy[k]
        if nx>=0 and nx<5 and ny>=0 and ny<5 and board[nx][ny]==1:
            DFS(nx, ny, board)

def solution(board):
    answer = 0
    for i in range(5):
        for j in range(5):
            if board[i][j] == 1:
                answer += 1
                DFS(i, j, board)
    return answer

### 픽셀수구하기
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]
def DFS(x, y, board):
    board[x][y] = 0
    cnt = 1
    for k in range(4):
        nx = x + dx[k]
        ny = y + dy[k]
        if nx>=0 and nx<5 and ny>=0 and ny<5 and board[nx][ny]==1:
            DFS(nx, ny, board)
            cnt += 1
    print('cnt : ',cnt)

def solution(board):
    answer = []
    answer = 0
    for i in range(5):
        for j in range(5):
            if board[i][j] == 1:
                answer += 1
                DFS(i, j, board)
    return answer
            
print(solution([[0, 1, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0], [0, 0, 1, 1, 0]]))
#print(solution([[1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [0, 0, 1, 0, 0], [1, 1, 0, 1, 0], [1, 0, 1, 0, 0]]))
#print(solution([[0, 0, 1, 0, 0], [0, 1, 1, 0, 0], [0, 1, 0, 0, 0], [1, 0, 0, 1, 0], [0, 0, 1, 1, 0]]))
#print(solution([[0, 0, 0, 0, 1], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 0, 1, 0, 0]]))

### 정답
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]
cnt = 0
def DFS(x, y, board):
    global cnt
    board[x][y] = 0
    cnt += 1
    for k in range(4):
        nx = x + dx[k]
        ny = y + dy[k]
        if nx>=0 and nx<5 and ny>=0 and ny<5 and board[nx][ny]==1:
            DFS(nx, ny, board)

def solution(board):
    global cnt
    answer = []
    for i in range(5):
        for j in range(5):
            if board[i][j] == 1:
                cnt = 0
                DFS(i, j, board)
                answer.append(cnt)
    return answer